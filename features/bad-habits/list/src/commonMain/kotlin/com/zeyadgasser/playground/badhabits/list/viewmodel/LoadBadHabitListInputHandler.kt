package com.zeyadgasser.playground.badhabits.list.viewmodel

import com.zeyadgasser.playground.architecture.presentation.InputHandler
import com.zeyadgasser.playground.architecture.presentation.Result
import com.zeyadgasser.playground.badhabits.domain.BadHabitRating
import com.zeyadgasser.playground.badhabits.domain.BadHabitsRepository
import com.zeyadgasser.playground.badhabits.list.viewmodel.BadHabitListState.EmptyState
import com.zeyadgasser.playground.badhabits.list.viewmodel.BadHabitListState.SuccessState
import com.zeyadgasser.playground.badhabits.sharedpresentation.BadHabitsPresentationMapper
import com.zeyadgasser.playground.utils.TimeService
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onStart

class LoadBadHabitListInputHandler(
    private val repository: BadHabitsRepository,
    private val taskPresentationMapper: BadHabitsPresentationMapper,
    private val timeService: TimeService,
) : InputHandler<LoadBadHabitListInput, BadHabitListState> {

    override fun invoke(input: LoadBadHabitListInput, currentState: BadHabitListState): Flow<Result> {
        return repository.getBadHabits().map { domainBadHabits ->
            val currentDate = timeService.getCurrentDateFormatted()
            val updatedBadHabits = domainBadHabits.map { badHabit ->
                // Check if a rating exists for the current date for this bad habit
                val hasTodayRating = badHabit.ratings.any { it.date == currentDate }
                if (!hasTodayRating) {
                    // If no rating for today, add a new one with value 0
                    val newRating = BadHabitRating(
                        id = 0L, // ID will be auto-generated by the DB on insert
                        ratingValue = 0,
                        date = currentDate
                    )
                    val updatedRatings = badHabit.ratings + newRating
                    // Update the bad habit in the repository
                    // We do this in a non-blocking way or as part of a larger transaction if needed
                    // For simplicity, directly call insertBadHabitWithRatings (which handles upsert)
                    repository.insertBadHabitWithRatings(badHabit.copy(ratings = updatedRatings))
                    badHabit.copy(ratings = updatedRatings) // Return updated domain object for mapping
                } else badHabit // No change needed if rating exists for today
            }
            taskPresentationMapper.mapToPresentationList(updatedBadHabits)
        }.map { if (it.isNotEmpty()) SuccessState(it, timeService.getCurrentDateLabel(), false) else EmptyState }
            .onStart { emit(SuccessState(emptyList(), timeService.getCurrentDateLabel(), true)) }
    }
}
